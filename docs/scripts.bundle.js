webpackJsonp([2,4],{

/***/ 1044:
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	if (typeof execScript !== "undefined")
		execScript(src);
	else
		eval.call(null, src);
}


/***/ }),

/***/ 1099:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(456);


/***/ }),

/***/ 456:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1044)(__webpack_require__(773))

/***/ }),

/***/ 773:
/***/ (function(module, exports) {

module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 2014-07-23\n *\n * By Eli Grey, http://eligrey.com\n * Public Domain.\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/\n\n/* Copied from MDN:\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/classList\n */\n\nif (\"document\" in window.self) {\n\n  // Full polyfill for browsers with no classList support\n  // Including IE < Edge missing SVGElement.classList\n  if (!(\"classList\" in document.createElement(\"_\"))\n    || document.createElementNS && !(\"classList\" in document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\"))) {\n\n  (function (view) {\n\n    \"use strict\";\n\n    if (!('Element' in view)) return;\n\n    var\n        classListProp = \"classList\"\n      , protoProp = \"prototype\"\n      , elemCtrProto = view.Element[protoProp]\n      , objCtr = Object\n      , strTrim = String[protoProp].trim || function () {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n      }\n      , arrIndexOf = Array[protoProp].indexOf || function (item) {\n        var\n            i = 0\n          , len = this.length\n        ;\n        for (; i < len; i++) {\n          if (i in this && this[i] === item) {\n            return i;\n          }\n        }\n        return -1;\n      }\n      // Vendors: please allow content code to instantiate DOMExceptions\n      , DOMEx = function (type, message) {\n        this.name = type;\n        this.code = DOMException[type];\n        this.message = message;\n      }\n      , checkTokenAndGetIndex = function (classList, token) {\n        if (token === \"\") {\n          throw new DOMEx(\n              \"SYNTAX_ERR\"\n            , \"An invalid or illegal string was specified\"\n          );\n        }\n        if (/\\s/.test(token)) {\n          throw new DOMEx(\n              \"INVALID_CHARACTER_ERR\"\n            , \"String contains an invalid character\"\n          );\n        }\n        return arrIndexOf.call(classList, token);\n      }\n      , ClassList = function (elem) {\n        var\n            trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\")\n          , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n          , i = 0\n          , len = classes.length\n        ;\n        for (; i < len; i++) {\n          this.push(classes[i]);\n        }\n        this._updateClassName = function () {\n          elem.setAttribute(\"class\", this.toString());\n        };\n      }\n      , classListProto = ClassList[protoProp] = []\n      , classListGetter = function () {\n        return new ClassList(this);\n      }\n    ;\n    // Most DOMException implementations don't allow calling DOMException's toString()\n    // on non-DOMExceptions. Error's toString() is sufficient here.\n    DOMEx[protoProp] = Error[protoProp];\n    classListProto.item = function (i) {\n      return this[i] || null;\n    };\n    classListProto.contains = function (token) {\n      token += \"\";\n      return checkTokenAndGetIndex(this, token) !== -1;\n    };\n    classListProto.add = function () {\n      var\n          tokens = arguments\n        , i = 0\n        , l = tokens.length\n        , token\n        , updated = false\n      ;\n      do {\n        token = tokens[i] + \"\";\n        if (checkTokenAndGetIndex(this, token) === -1) {\n          this.push(token);\n          updated = true;\n        }\n      }\n      while (++i < l);\n\n      if (updated) {\n        this._updateClassName();\n      }\n    };\n    classListProto.remove = function () {\n      var\n          tokens = arguments\n        , i = 0\n        , l = tokens.length\n        , token\n        , updated = false\n        , index\n      ;\n      do {\n        token = tokens[i] + \"\";\n        index = checkTokenAndGetIndex(this, token);\n        while (index !== -1) {\n          this.splice(index, 1);\n          updated = true;\n          index = checkTokenAndGetIndex(this, token);\n        }\n      }\n      while (++i < l);\n\n      if (updated) {\n        this._updateClassName();\n      }\n    };\n    classListProto.toggle = function (token, force) {\n      token += \"\";\n\n      var\n          result = this.contains(token)\n        , method = result ?\n          force !== true && \"remove\"\n        :\n          force !== false && \"add\"\n      ;\n\n      if (method) {\n        this[method](token);\n      }\n\n      if (force === true || force === false) {\n        return force;\n      } else {\n        return !result;\n      }\n    };\n    classListProto.toString = function () {\n      return this.join(\" \");\n    };\n\n    if (objCtr.defineProperty) {\n      var classListPropDesc = {\n          get: classListGetter\n        , enumerable: true\n        , configurable: true\n      };\n      try {\n        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n      } catch (ex) { // IE 8 doesn't support enumerable:true\n        if (ex.number === -0x7FF5EC54) {\n          classListPropDesc.enumerable = false;\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        }\n      }\n    } else if (objCtr[protoProp].__defineGetter__) {\n      elemCtrProto.__defineGetter__(classListProp, classListGetter);\n    }\n\n    }(window.self));\n\n    } else {\n    // There is full or partial native classList support, so just check if we need\n    // to normalize the add/remove and toggle APIs.\n\n    (function () {\n      \"use strict\";\n\n      var testElement = document.createElement(\"_\");\n\n      testElement.classList.add(\"c1\", \"c2\");\n\n      // Polyfill for IE 10/11 and Firefox <26, where classList.add and\n      // classList.remove exist but support only one argument at a time.\n      if (!testElement.classList.contains(\"c2\")) {\n        var createMethod = function(method) {\n          var original = DOMTokenList.prototype[method];\n\n          DOMTokenList.prototype[method] = function(token) {\n            var i, len = arguments.length;\n\n            for (i = 0; i < len; i++) {\n              token = arguments[i];\n              original.call(this, token);\n            }\n          };\n        };\n        createMethod('add');\n        createMethod('remove');\n      }\n\n      testElement.classList.toggle(\"c3\", false);\n\n      // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n      // support the second argument.\n      if (testElement.classList.contains(\"c3\")) {\n        var _toggle = DOMTokenList.prototype.toggle;\n\n        DOMTokenList.prototype.toggle = function(token, force) {\n          if (1 in arguments && !this.contains(token) === !force) {\n            return force;\n          } else {\n            return _toggle.call(this, token);\n          }\n        };\n\n      }\n\n      testElement = null;\n    }());\n  }\n}\n\n},{}],2:[function(require,module,exports){\n(function (global){\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],3:[function(require,module,exports){\nvar select = require('../utils/select');\n\n/**\n * @name showPanelListener\n * @desc The event handler for clicking on a button in an accordion.\n * @param {HTMLElement} el - An HTML element most likely a <button>.\n * @param {Object} ev - A DOM event object.\n */\nfunction showPanelListener (el, ev) {\n  var expanded = el.getAttribute('aria-expanded') === 'true';\n  this.hideAll();\n  if (!expanded) {\n    this.show(el);\n  }\n  return false;\n}\n\n/**\n * @class Accordion\n *\n * An accordion component.\n *\n * @param {HTMLElement} el An HTMLElement to turn into an accordion.\n */\nfunction Accordion (el) {\n  var self = this;\n  this.root = el;\n\n  // delegate click events on each <button>\n  var buttons = select('button', this.root);\n  buttons.forEach(function (el) {\n    if (el.attachEvent) {\n      el.attachEvent('onclick', showPanelListener.bind(self, el));\n    } else {\n      el.addEventListener('click', showPanelListener.bind(self, el));\n    }\n  });\n\n  // find the first expanded button\n  var expanded = this.$('button[aria-expanded=true]')[ 0 ];\n  this.hideAll();\n  if (expanded !== undefined) {\n    this.show(expanded);\n  }\n}\n\n/**\n * @param {String} selector\n * @return {Array}\n */\nAccordion.prototype.$ = function (selector) {\n  return select(selector, this.root);\n};\n\n/**\n * @param {HTMLElement} button\n * @return {Accordion}\n */\nAccordion.prototype.hide = function (button) {\n  var selector = button.getAttribute('aria-controls'),\n    content = this.$('#' + selector)[ 0 ];\n\n  button.setAttribute('aria-expanded', false);\n  content.setAttribute('aria-hidden', true);\n  return this;\n};\n\n/**\n * @param {HTMLElement} button\n * @return {Accordion}\n */\nAccordion.prototype.show = function (button) {\n  var selector = button.getAttribute('aria-controls'),\n    content = this.$('#' + selector)[ 0 ];\n\n  button.setAttribute('aria-expanded', true);\n  content.setAttribute('aria-hidden', false);\n  return this;\n};\n\n/**\n * @return {Accordion}\n */\nAccordion.prototype.hideAll = function () {\n  var self = this;\n  var buttons = this.$('ul > li > button, .usa-accordion-button');\n  buttons.forEach(function (button) {\n    self.hide(button);\n  });\n  return this;\n};\n\nmodule.exports = Accordion;\n\n},{\"../utils/select\":22}],4:[function(require,module,exports){\nvar select = require('../utils/select');\nvar dispatch = require('../utils/dispatch');\n\nfunction bannerClickHandler (event) {\n  (event.preventDefault) ? event.preventDefault() : event.returnValue = false;\n\n  this.classList.toggle('usa-banner-header-expanded');\n}\n\nfunction bannerInit () {\n  var banners = select('.usa-banner-header');\n\n  banners.forEach(function (banner) {\n    var bannerClick = bannerClickHandler.bind(banner);\n    select('[aria-controls]', banner).forEach(function (button) {\n      dispatch(button, 'click', bannerClick);\n    });\n  });\n}\n\nmodule.exports = bannerInit;\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22}],5:[function(require,module,exports){\nvar select = require('../utils/select');\nvar dispatch = require('../utils/dispatch');\n\nfunction getSiblings (el) {\n  var n = el.parentNode.firstChild;\n  var matches = [];\n\n  while (n) {\n    if (n.nodeType == 1 && n != el) {\n      matches.push(n);\n    }\n    n = n.nextSibling;\n  }\n\n  return matches;\n}\n\nvar showPanelListener = function () {\n  var panelToShow = this.parentNode;\n  var otherPanels = getSiblings(panelToShow);\n  panelToShow.classList.remove('hidden');\n  otherPanels.forEach(function (el) {\n    el.classList.add('hidden');\n  });\n};\n\nvar events = [];\n\nmodule.exports = function footerAccordion () {\n\n  var navList = select('.usa-footer-big nav ul');\n  var primaryLink = select('.usa-footer-big nav .usa-footer-primary-link');\n\n  if (events.length) {\n    events.forEach(function (e) {\n      e.off();\n    });\n    events = [];\n  }\n\n  if (window.innerWidth < 600) {\n\n    navList.forEach(function (el) {\n      el.classList.add('hidden');\n    });\n\n    primaryLink.forEach(function (el) {\n      events.push(\n        dispatch(el, 'click', showPanelListener)\n      );\n    });\n\n  } else {\n    navList.forEach(function (el) {\n      el.classList.remove('hidden');\n    });\n  }\n};\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22}],6:[function(require,module,exports){\nvar select = require('../utils/select');\nvar dispatch = require('../utils/dispatch');\n\nvar clickEvent = ('ontouchstart' in document.documentElement ? 'touchstart' : 'click');\nvar dispatchers = [];\n\nfunction handleNavElements (e) {\n\n  var toggleElements = select('.usa-overlay, .usa-nav');\n  var navCloseElement = select('.usa-nav-close')[ 0 ];\n\n  toggleElements.forEach(function (element) {\n    element.classList.toggle('is-visible');\n  });\n\n  document.body.classList.toggle('usa-mobile_nav-active');\n  navCloseElement.focus();\n\n  return false;\n}\n\nfunction navInit () {\n  var navElements = select('.usa-menu-btn, .usa-overlay, .usa-nav-close');\n\n  dispatchers = navElements.map(function (element) {\n    return dispatch(element, clickEvent, handleNavElements);\n  });\n}\n\nfunction navOff () {\n  while (dispatchers.length) {\n    dispatchers.pop().off();\n  }\n}\n\nmodule.exports = navInit;\nmodule.exports.off = navOff;\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22}],7:[function(require,module,exports){\nvar select = require('../utils/select');\nvar dispatch = require('../utils/dispatch');\n\nvar VISUALLY_HIDDEN = 'usa-sr-only';\n\nvar clickEvent = ('ontouchstart' in document.documentElement)\n  ? 'touchstart'\n  : 'click';\n\nvar searchForm;\nvar searchButton;\nvar searchButtonContainer;\n\nvar activateDispatcher;\nvar deactivateDispatcher;\n\nfunction searchButtonClickHandler (event) {\n  if (searchForm.hidden) {\n    closeSearch();\n  } else {\n    openSearch();\n    deactivateDispatcher = dispatch(document.body, clickEvent, searchOpenClickHandler);\n  }\n\n  return false;\n}\n\nfunction searchOpenClickHandler (event) {\n  if (! searchFormContains(event.target)) {\n    closeSearch();\n    deactivateDispatcher.off();\n    deactivateDispatcher = undefined;\n  }\n}\n\nfunction openSearch () {\n  searchForm.classList.remove(VISUALLY_HIDDEN);\n  var input = searchForm.querySelector('[type=search]');\n  if (input) {\n    input.focus();\n  }\n  searchButton.hidden = true;\n}\n\nfunction closeSearch () {\n  searchForm.classList.add(VISUALLY_HIDDEN);\n  searchButton.hidden = false;\n}\n\nfunction searchFormContains (element) {\n  return (searchForm && searchForm.contains(element)) ||\n         (searchButtonContainer && searchButtonContainer.contains(element));\n}\n\nfunction searchInit () {\n  searchForm = select('.js-search-form')[ 0 ];\n  searchButton = select('.js-search-button')[ 0 ];\n  searchButtonContainer = select('.js-search-button-container')[ 0 ];\n\n  if (searchButton && searchForm) {\n    closeSearch();\n    activateDispatcher = dispatch(searchButton, clickEvent, searchButtonClickHandler);\n  }\n}\n\nfunction searchOff () {\n  if (activateDispatcher) {\n    activateDispatcher.off();\n  }\n  if (deactivateDispatcher) {\n    deactivateDispatcher.off();\n  }\n}\n\nmodule.exports = searchInit;\nmodule.exports.off = searchOff;\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22}],8:[function(require,module,exports){\n/**\n * Flips given INPUT elements between masked (hiding the field value) and unmasked\n * @param {Array.HTMLElement} fields - An array of INPUT elements\n * @param {Boolean} mask - Whether the mask should be applied, hiding the field value\n */\nmodule.exports = function (fields, mask) {\n  fields.forEach(function (field) {\n    field.setAttribute('autocapitalize', 'off');\n    field.setAttribute('autocorrect', 'off');\n    field.setAttribute('type', mask ? 'password' : 'text');\n  });\n};\n\n},{}],9:[function(require,module,exports){\nvar toggleFieldMask = require('./toggle-field-mask');\nvar select = require('../utils/select');\n\n/**\n * Component that decorates an HTML element with the ability to toggle the\n * masked state of an input field (like a password) when clicked.\n * The ids of the fields to be masked will be pulled directly from the button's\n * `aria-controls` attribute.\n *\n * @param  {HTMLElement} el    Parent element containing the fields to be masked\n * @param  {String} showText   Button text shown when field is masked\n * @param  {String} hideText   Button text show when field is unmasked\n * @return {}\n */\nvar toggleFormInput = function (el, showText, hideText) {\n  var defaultSelectors = el.getAttribute('aria-controls');\n\n  if (!defaultSelectors || defaultSelectors.trim().length === 0) {\n    throw new Error('Did you forget to define selectors in the aria-controls attribute? Check element ' + el.outerHTML);\n  }\n\n  var fieldSelector = getSelectors(defaultSelectors);\n  var formElement = getFormParent(el);\n  if (!formElement) {\n    throw new Error('toggleFormInput() needs the supplied element to be inside a <form>. Check element ' + el.outerHTML);\n  }\n  var fields = select(fieldSelector, formElement);\n  var masked = false;\n\n  var toggleClickListener = function (ev) {\n    ev.preventDefault();\n    toggleFieldMask(fields, masked);\n    el.textContent = masked ? showText : hideText;\n    masked = !masked;\n  };\n\n  if (el.attachEvent) {\n    el.attachEvent('onclick', toggleClickListener);\n  } else {\n    el.addEventListener('click', toggleClickListener);\n  }\n};\n\n/**\n * Helper function to turn a string of ids into valid selectors\n * @param  {String} selectors Space separated list of ids of fields to be masked\n * @return {String}           Comma separated list of selectors\n */\nfunction getSelectors (selectors) {\n  var selectorsList = selectors.split(' ');\n\n  return selectorsList.map(function (selector) {\n    return '#' + selector;\n  }).join(', ');\n}\n\n/**\n * Searches up the tree from the element to find a Form element, and returns it,\n * or null if no Form is found\n * @param {HTMLElement} el - Child element to start search\n */\nfunction getFormParent (el) {\n  while (el && el.tagName !== 'FORM') {\n    el = el.parentNode;\n  }\n  return el;\n}\n\nmodule.exports = toggleFormInput;\n\n},{\"../utils/select\":22,\"./toggle-field-mask\":8}],10:[function(require,module,exports){\nvar select = require('../utils/select');\nvar dispatch = require('../utils/dispatch');\n\nmodule.exports = function validator (el) {\n  var data = getData(el);\n  var key;\n  var validatorName;\n  var validatorPattern;\n  var validatorCheckbox;\n  var checkList = select(data.validationelement)[ 0 ];\n\n  function validate () {\n    for (key in data) {\n      if (key.startsWith('validate')) {\n        validatorName = key.split('validate')[ 1 ];\n        validatorPattern = new RegExp(data[ key ]);\n        validatorSelector = '[data-validator=' + validatorName + ']';\n        validatorCheckbox = select(validatorSelector, checkList)[ 0 ];\n\n        var checked = validatorPattern.test(el.value);\n        validatorCheckbox.classList.toggle('usa-checklist-checked', checked);\n      }\n    }\n  }\n\n  dispatch(el, 'keyup', validate);\n};\n\n/**\n * Extracts attributes named with the pattern \"data-[NAME]\" from a given\n * HTMLElement, then returns an object populated with the NAME/value pairs.\n * Any hyphens in NAME are removed.\n * @param {HTMLElement} el\n * @return {Object}\n */\n\nfunction getData (el) {\n  if (!el.hasAttributes()) return;\n  var data = {};\n  var attrs = el.attributes;\n  for (var i = attrs.length - 1; i >= 0; i--) {\n    var matches = attrs[ i ].name.match(/data-(.*)/i);\n    if (matches && matches[ 1 ]) {\n      var name = matches[ 1 ].replace(/-/, '');\n      data[ name ] = attrs[ i ].value;\n    }\n  }\n  return data;\n}\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22}],11:[function(require,module,exports){\nvar select = require('../utils/select');\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar Accordion = require('../components/accordion');\n\nwhenDOMReady(function initAccordions () {\n\n  var accordions = select('.usa-accordion, .usa-accordion-bordered');\n  accordions.forEach(function (el) {\n    new Accordion(el);\n  });\n});\n\n},{\"../components/accordion\":3,\"../utils/select\":22,\"../utils/when-dom-ready\":23}],12:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar bannerInit = require('../components/banner');\n\nwhenDOMReady(function () {\n\n  bannerInit();\n\n});\n\n\n},{\"../components/banner\":4,\"../utils/when-dom-ready\":23}],13:[function(require,module,exports){\nvar debounce = require('lodash.debounce');\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar dispatch = require('../utils/dispatch');\nvar footerAccordion = require('../components/footer');\n\nwhenDOMReady(function () {\n\n  footerAccordion();\n\n  dispatch(window, 'resize', debounce(footerAccordion, 180));\n\n});\n\n},{\"../components/footer\":5,\"../utils/dispatch\":21,\"../utils/when-dom-ready\":23,\"lodash.debounce\":2}],14:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar select = require('../utils/select');\nvar validator = require('../components/validator');\nvar toggleFormInput = require('../components/toggle-form-input');\n\nwhenDOMReady(function () {\n  var elShowPassword = select('.usa-show_password')[ 0 ];\n  var elFormInput = select('.usa-show_multipassword')[ 0 ];\n  var elValidator = select('.js-validate_password')[ 0 ];\n\n  elShowPassword && toggleFormInput(elShowPassword, 'Show Password', 'Hide Password');\n  elFormInput && toggleFormInput(elFormInput, 'Show my typing', 'Hide my typing');\n  elValidator && validator(elValidator);\n});\n\n\n},{\"../components/toggle-form-input\":9,\"../components/validator\":10,\"../utils/select\":22,\"../utils/when-dom-ready\":23}],15:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar navInit = require('../components/navigation');\n\nwhenDOMReady(navInit);\n\n},{\"../components/navigation\":6,\"../utils/when-dom-ready\":23}],16:[function(require,module,exports){\n// support for HTMLElement#hidden\nrequire('../polyfills/element-hidden');\n// support for Element#classList\nrequire('classlist-polyfill');\n\n/**\n * This file defines key ECMAScript 5 methods that are used by the Standards\n * but may be missing in older browsers.\n */\n\n/**\n * Array.prototype.forEach()\n * Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n */\n\n// Production steps of ECMA-262, Edition 5, 15.4.4.18\n// Reference: http://es5.github.io/#x15.4.4.18\nif (!Array.prototype.forEach) {\n\n  Array.prototype.forEach = function (callback, thisArg) {\n\n    var T, k;\n\n    if (this === null) {\n      throw new TypeError(' this is null or not defined');\n    }\n\n    // 1. Let O be the result of calling toObject() passing the\n    // |this| value as the argument.\n    var O = Object(this);\n\n    // 2. Let lenValue be the result of calling the Get() internal\n    // method of O with the argument \"length\".\n    // 3. Let len be toUint32(lenValue).\n    var len = O.length >>> 0;\n\n    // 4. If isCallable(callback) is false, throw a TypeError exception. \n    // See: http://es5.github.com/#x9.11\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback + ' is not a function');\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let\n    // T be undefined.\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n\n    // 6. Let k be 0\n    k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n\n      var kValue;\n\n      // a. Let Pk be ToString(k).\n      //    This is implicit for LHS operands of the in operator\n      // b. Let kPresent be the result of calling the HasProperty\n      //    internal method of O with argument Pk.\n      //    This step can be combined with c\n      // c. If kPresent is true, then\n      if (k in O) {\n\n        // i. Let kValue be the result of calling the Get internal\n        // method of O with argument Pk.\n        kValue = O[ k ];\n\n        // ii. Call the Call internal method of callback with T as\n        // the this value and argument list containing kValue, k, and O.\n        callback.call(T, kValue, k, O);\n      }\n      // d. Increase k by 1.\n      k++;\n    }\n    // 8. return undefined\n  };\n}\n\n\n/**\n * Function.prototype.bind()\n * Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n */\n\n// Reference: http://es5.github.io/#x15.3.4.5\nif (!Function.prototype.bind) {\n\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n      fToBind = this,\n      fNOP    = function () {},\n      fBound  = function () {\n        return fToBind.apply(this instanceof fNOP ? this : oThis,\n                aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype; \n    }\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n\n}\n\n},{\"../polyfills/element-hidden\":19,\"classlist-polyfill\":1}],17:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar searchInit = require('../components/search');\n\nwhenDOMReady(searchInit);\n\n},{\"../components/search\":7,\"../utils/when-dom-ready\":23}],18:[function(require,module,exports){\nvar dispatch = require('../utils/dispatch');\nvar select = require('../utils/select');\nvar whenDOMReady = require('../utils/when-dom-ready');\n\nwhenDOMReady(function () {\n\n  // Fixing skip nav focus behavior in chrome\n  var elSkipnav = select('.skipnav')[ 0 ];\n  var elMainContent = select('#main-content')[ 0 ];\n\n  if (elSkipnav) {\n    dispatch(elSkipnav, 'click', function () {\n      elMainContent.setAttribute('tabindex', '0');\n    });\n  }\n\n  if (elMainContent) {\n    dispatch(elMainContent, 'blur', function () {\n      elMainContent.setAttribute('tabindex', '-1');\n    });\n  }\n});\n\n},{\"../utils/dispatch\":21,\"../utils/select\":22,\"../utils/when-dom-ready\":23}],19:[function(require,module,exports){\nvar elproto = window.HTMLElement.prototype;\nvar HIDDEN = 'hidden';\n\nif (!(HIDDEN in elproto)) {\n\n  Object.defineProperty(elproto, HIDDEN, {\n    get: function () {\n      return this.hasAttribute(HIDDEN);\n    },\n    set: function (value) {\n      if (value) {\n        this.setAttribute(HIDDEN, '');\n      } else {\n        this.removeAttribute(HIDDEN);\n      }\n    },\n  });\n}\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\n/**\n * The 'polyfills' file defines key ECMAScript 5 methods that may be\n * missing from older browsers, so must be loaded first.\n */\nrequire('./initializers/polyfills');\n\nrequire('./initializers/accordions');\nrequire('./initializers/banner');\nrequire('./initializers/footer');\nrequire('./initializers/forms');\nrequire('./initializers/navigation');\nrequire('./initializers/search');\nrequire('./initializers/skip-nav');\n\n},{\"./initializers/accordions\":11,\"./initializers/banner\":12,\"./initializers/footer\":13,\"./initializers/forms\":14,\"./initializers/navigation\":15,\"./initializers/polyfills\":16,\"./initializers/search\":17,\"./initializers/skip-nav\":18}],21:[function(require,module,exports){\n/**\n * Attaches a given listener function to a given element which is\n * triggered by a specified list of event types.\n * @param {HTMLElement} element - the element to which the listener will be attached\n * @param {String} eventTypes - space-separated list of event types which will trigger the listener\n * @param {Function} listener - the function to be executed\n * @returns {Object} - containing a <tt>trigger()</tt> method for executing the listener, and an <tt>off()</tt> method for detaching it\n */\nmodule.exports = function dispatch (element, eventTypes, listener, options) {\n  var eventTypeArray = eventTypes.split(/\\s+/);\n\n  var attach = function (e, t, d) {\n    if (e.attachEvent) {\n      e.attachEvent('on' + t, d, options);\n    }\n    if (e.addEventListener) {\n      e.addEventListener(t, d, options);\n    }\n  };\n\n  var trigger = function (e, t) {\n    var fakeEvent;\n    if ('createEvent' in document) {\n      // modern browsers, IE9+\n      fakeEvent = document.createEvent('HTMLEvents');\n      fakeEvent.initEvent(t, false, true);\n      e.dispatchEvent(fakeEvent);\n    } else {\n      // IE 8\n      fakeEvent = document.createEventObject();\n      fakeEvent.eventType = t;\n      e.fireEvent('on'+e.eventType, fakeEvent);\n    }\n  };\n\n  var detach = function (e, t, d) {\n    if (e.detachEvent) {\n      e.detachEvent('on' + t, d, options);\n    }\n    if (e.removeEventListener) {\n      e.removeEventListener(t, d, options);\n    }\n  };\n\n  eventTypeArray.forEach(function (eventType) {\n    attach.call(null, element, eventType, listener);\n  });\n\n  return {\n    trigger: function () {\n      trigger.call(null, element, eventTypeArray[ 0 ]);\n    },\n    off: function () {\n      eventTypeArray.forEach(function (eventType) {\n        detach.call(null, element, eventType, listener);\n      });\n    },\n  };\n};\n\n},{}],22:[function(require,module,exports){\n/**\n * @name select\n * @desc selects elements from the DOM by class selector or ID selector.\n * @param {string} selector - The selector to traverse the DOM with.\n * @param {HTMLElement} context - The context to traverse the DOM in.\n * @return {Array.HTMLElement} - An array of DOM nodes or an empty array.\n */\nmodule.exports = function select (selector, context) {\n\n  if (typeof selector !== 'string') {\n    return [];\n  }\n\n  if ((context === undefined) || !isElement(context)) {\n    context = window.document;\n  }\n\n  var selection = context.querySelectorAll(selector);\n\n  return Array.prototype.slice.call(selection);\n\n};\n\nfunction isElement (value) {\n  return !!value && typeof value === 'object' && value.nodeType === 1;\n}\n},{}],23:[function(require,module,exports){\n/*\n * @name DOMLoaded\n * @param {function} cb - The callback function to run when the DOM has loaded.\n */\nmodule.exports = function DOMLoaded (cb) {\n  // in case the document is already rendered\n  if ('loading' !== document.readyState) {\n    if (isFunction(cb)) {\n      cb();\n    }\n  } else if (document.addEventListener) { // modern browsers\n    document.addEventListener('DOMContentLoaded', cb);\n  } else { // IE <= 8\n    document.attachEvent('onreadystatechange', function (){\n      if ('complete' === document.readyState) {\n        if (isFunction(cb)) {\n          cb();\n        }\n      }\n    });\n  }\n};\n\nfunction isFunction (arg) {\n  return (typeof arg === 'function');\n}\n},{}]},{},[20])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2xhc3NsaXN0LXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJzcmMvanMvY29tcG9uZW50cy9hY2NvcmRpb24uanMiLCJzcmMvanMvY29tcG9uZW50cy9iYW5uZXIuanMiLCJzcmMvanMvY29tcG9uZW50cy9mb290ZXIuanMiLCJzcmMvanMvY29tcG9uZW50cy9uYXZpZ2F0aW9uLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvc2VhcmNoLmpzIiwic3JjL2pzL2NvbXBvbmVudHMvdG9nZ2xlLWZpZWxkLW1hc2suanMiLCJzcmMvanMvY29tcG9uZW50cy90b2dnbGUtZm9ybS1pbnB1dC5qcyIsInNyYy9qcy9jb21wb25lbnRzL3ZhbGlkYXRvci5qcyIsInNyYy9qcy9pbml0aWFsaXplcnMvYWNjb3JkaW9ucy5qcyIsInNyYy9qcy9pbml0aWFsaXplcnMvYmFubmVyLmpzIiwic3JjL2pzL2luaXRpYWxpemVycy9mb290ZXIuanMiLCJzcmMvanMvaW5pdGlhbGl6ZXJzL2Zvcm1zLmpzIiwic3JjL2pzL2luaXRpYWxpemVycy9uYXZpZ2F0aW9uLmpzIiwic3JjL2pzL2luaXRpYWxpemVycy9wb2x5ZmlsbHMuanMiLCJzcmMvanMvaW5pdGlhbGl6ZXJzL3NlYXJjaC5qcyIsInNyYy9qcy9pbml0aWFsaXplcnMvc2tpcC1uYXYuanMiLCJzcmMvanMvcG9seWZpbGxzL2VsZW1lbnQtaGlkZGVuLmpzIiwic3JjL2pzL3N0YXJ0LmpzIiwic3JjL2pzL3V0aWxzL2Rpc3BhdGNoLmpzIiwic3JjL2pzL3V0aWxzL3NlbGVjdC5qcyIsInNyYy9qcy91dGlscy93aGVuLWRvbS1yZWFkeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIGNsYXNzTGlzdC5qczogQ3Jvc3MtYnJvd3NlciBmdWxsIGVsZW1lbnQuY2xhc3NMaXN0IGltcGxlbWVudGF0aW9uLlxuICogMjAxNC0wNy0yM1xuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIFB1YmxpYyBEb21haW4uXG4gKiBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG4gKi9cblxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyovXG5cbi8qIENvcGllZCBmcm9tIE1ETjpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsYXNzTGlzdFxuICovXG5cbmlmIChcImRvY3VtZW50XCIgaW4gd2luZG93LnNlbGYpIHtcblxuICAvLyBGdWxsIHBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XG4gIC8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxuICBpZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKVxuICAgIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XG5cbiAgKGZ1bmN0aW9uICh2aWV3KSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xuXG4gICAgdmFyXG4gICAgICAgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXG4gICAgICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcbiAgICAgICwgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF1cbiAgICAgICwgb2JqQ3RyID0gT2JqZWN0XG4gICAgICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICB9XG4gICAgICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcbiAgICAgICAgO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXG4gICAgICAsIERPTUV4ID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdHlwZTtcbiAgICAgICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXG4gICAgICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXG4gICAgICAgICAgICAsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeChcbiAgICAgICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxuICAgICAgICAgICAgLCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJySW5kZXhPZi5jYWxsKGNsYXNzTGlzdCwgdG9rZW4pO1xuICAgICAgfVxuICAgICAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcbiAgICAgICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxuICAgICAgICAgICwgaSA9IDBcbiAgICAgICAgICAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXG4gICAgICAgIDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMucHVzaChjbGFzc2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cbiAgICAgICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcbiAgICAgIH1cbiAgICA7XG4gICAgLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuICAgIC8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuICAgIERPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xuICAgIGNsYXNzTGlzdFByb3RvLml0ZW0gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbiAgICB9O1xuICAgIGNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICB0b2tlbiArPSBcIlwiO1xuICAgICAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xuICAgIH07XG4gICAgY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyXG4gICAgICAgICAgdG9rZW5zID0gYXJndW1lbnRzXG4gICAgICAgICwgaSA9IDBcbiAgICAgICAgLCBsID0gdG9rZW5zLmxlbmd0aFxuICAgICAgICAsIHRva2VuXG4gICAgICAgICwgdXBkYXRlZCA9IGZhbHNlXG4gICAgICA7XG4gICAgICBkbyB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcbiAgICAgICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhclxuICAgICAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xuICAgICAgICAsIGkgPSAwXG4gICAgICAgICwgbCA9IHRva2Vucy5sZW5ndGhcbiAgICAgICAgLCB0b2tlblxuICAgICAgICAsIHVwZGF0ZWQgPSBmYWxzZVxuICAgICAgICAsIGluZGV4XG4gICAgICA7XG4gICAgICBkbyB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcbiAgICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuICAgICAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICAgIHRva2VuICs9IFwiXCI7XG5cbiAgICAgIHZhclxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXG4gICAgICAgICwgbWV0aG9kID0gcmVzdWx0ID9cbiAgICAgICAgICBmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXG4gICAgICAgIDpcbiAgICAgICAgICBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIlxuICAgICAgO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHRoaXNbbWV0aG9kXSh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzc0xpc3RQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xuICAgIH07XG5cbiAgICBpZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XG4gICAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XG4gICAgICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcbiAgICAgICAgLCBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgfSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG4gICAgICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuICAgICAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcbiAgICB9XG5cbiAgICB9KHdpbmRvdy5zZWxmKSk7XG5cbiAgICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxuICAgIC8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuXG4gICAgICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYzFcIiwgXCJjMlwiKTtcblxuICAgICAgLy8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcbiAgICAgIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxuICAgICAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xuICAgICAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xuXG4gICAgICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgIG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XG4gICAgICAgIGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XG4gICAgICB9XG5cbiAgICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7XG5cbiAgICAgIC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcbiAgICAgIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xuICAgICAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xuXG4gICAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24odG9rZW4sIGZvcmNlKSB7XG4gICAgICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgfVxuXG4gICAgICB0ZXN0RWxlbWVudCA9IG51bGw7XG4gICAgfSgpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwidmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NlbGVjdCcpO1xuXG4vKipcbiAqIEBuYW1lIHNob3dQYW5lbExpc3RlbmVyXG4gKiBAZGVzYyBUaGUgZXZlbnQgaGFuZGxlciBmb3IgY2xpY2tpbmcgb24gYSBidXR0b24gaW4gYW4gYWNjb3JkaW9uLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBBbiBIVE1MIGVsZW1lbnQgbW9zdCBsaWtlbHkgYSA8YnV0dG9uPi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldiAtIEEgRE9NIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gc2hvd1BhbmVsTGlzdGVuZXIgKGVsLCBldikge1xuICB2YXIgZXhwYW5kZWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSA9PT0gJ3RydWUnO1xuICB0aGlzLmhpZGVBbGwoKTtcbiAgaWYgKCFleHBhbmRlZCkge1xuICAgIHRoaXMuc2hvdyhlbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBjbGFzcyBBY2NvcmRpb25cbiAqXG4gKiBBbiBhY2NvcmRpb24gY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEFuIEhUTUxFbGVtZW50IHRvIHR1cm4gaW50byBhbiBhY2NvcmRpb24uXG4gKi9cbmZ1bmN0aW9uIEFjY29yZGlvbiAoZWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJvb3QgPSBlbDtcblxuICAvLyBkZWxlZ2F0ZSBjbGljayBldmVudHMgb24gZWFjaCA8YnV0dG9uPlxuICB2YXIgYnV0dG9ucyA9IHNlbGVjdCgnYnV0dG9uJywgdGhpcy5yb290KTtcbiAgYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5hdHRhY2hFdmVudCkge1xuICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uY2xpY2snLCBzaG93UGFuZWxMaXN0ZW5lci5iaW5kKHNlbGYsIGVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2hvd1BhbmVsTGlzdGVuZXIuYmluZChzZWxmLCBlbCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZmluZCB0aGUgZmlyc3QgZXhwYW5kZWQgYnV0dG9uXG4gIHZhciBleHBhbmRlZCA9IHRoaXMuJCgnYnV0dG9uW2FyaWEtZXhwYW5kZWQ9dHJ1ZV0nKVsgMCBdO1xuICB0aGlzLmhpZGVBbGwoKTtcbiAgaWYgKGV4cGFuZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNob3coZXhwYW5kZWQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQWNjb3JkaW9uLnByb3RvdHlwZS4kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMucm9vdCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ1dHRvblxuICogQHJldHVybiB7QWNjb3JkaW9ufVxuICovXG5BY2NvcmRpb24ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoYnV0dG9uKSB7XG4gIHZhciBzZWxlY3RvciA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSxcbiAgICBjb250ZW50ID0gdGhpcy4kKCcjJyArIHNlbGVjdG9yKVsgMCBdO1xuXG4gIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnV0dG9uXG4gKiBAcmV0dXJuIHtBY2NvcmRpb259XG4gKi9cbkFjY29yZGlvbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChidXR0b24pIHtcbiAgdmFyIHNlbGVjdG9yID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpLFxuICAgIGNvbnRlbnQgPSB0aGlzLiQoJyMnICsgc2VsZWN0b3IpWyAwIF07XG5cbiAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtBY2NvcmRpb259XG4gKi9cbkFjY29yZGlvbi5wcm90b3R5cGUuaGlkZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYnV0dG9ucyA9IHRoaXMuJCgndWwgPiBsaSA+IGJ1dHRvbiwgLnVzYS1hY2NvcmRpb24tYnV0dG9uJyk7XG4gIGJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgc2VsZi5oaWRlKGJ1dHRvbik7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjb3JkaW9uO1xuIiwidmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NlbGVjdCcpO1xudmFyIGRpc3BhdGNoID0gcmVxdWlyZSgnLi4vdXRpbHMvZGlzcGF0Y2gnKTtcblxuZnVuY3Rpb24gYmFubmVyQ2xpY2tIYW5kbGVyIChldmVudCkge1xuICAoZXZlbnQucHJldmVudERlZmF1bHQpID8gZXZlbnQucHJldmVudERlZmF1bHQoKSA6IGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKCd1c2EtYmFubmVyLWhlYWRlci1leHBhbmRlZCcpO1xufVxuXG5mdW5jdGlvbiBiYW5uZXJJbml0ICgpIHtcbiAgdmFyIGJhbm5lcnMgPSBzZWxlY3QoJy51c2EtYmFubmVyLWhlYWRlcicpO1xuXG4gIGJhbm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYmFubmVyKSB7XG4gICAgdmFyIGJhbm5lckNsaWNrID0gYmFubmVyQ2xpY2tIYW5kbGVyLmJpbmQoYmFubmVyKTtcbiAgICBzZWxlY3QoJ1thcmlhLWNvbnRyb2xzXScsIGJhbm5lcikuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICBkaXNwYXRjaChidXR0b24sICdjbGljaycsIGJhbm5lckNsaWNrKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFubmVySW5pdDtcbiIsInZhciBzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9zZWxlY3QnKTtcbnZhciBkaXNwYXRjaCA9IHJlcXVpcmUoJy4uL3V0aWxzL2Rpc3BhdGNoJyk7XG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdzIChlbCkge1xuICB2YXIgbiA9IGVsLnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICB3aGlsZSAobikge1xuICAgIGlmIChuLm5vZGVUeXBlID09IDEgJiYgbiAhPSBlbCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKG4pO1xuICAgIH1cbiAgICBuID0gbi5uZXh0U2libGluZztcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG52YXIgc2hvd1BhbmVsTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYW5lbFRvU2hvdyA9IHRoaXMucGFyZW50Tm9kZTtcbiAgdmFyIG90aGVyUGFuZWxzID0gZ2V0U2libGluZ3MocGFuZWxUb1Nob3cpO1xuICBwYW5lbFRvU2hvdy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgb3RoZXJQYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgfSk7XG59O1xuXG52YXIgZXZlbnRzID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9vdGVyQWNjb3JkaW9uICgpIHtcblxuICB2YXIgbmF2TGlzdCA9IHNlbGVjdCgnLnVzYS1mb290ZXItYmlnIG5hdiB1bCcpO1xuICB2YXIgcHJpbWFyeUxpbmsgPSBzZWxlY3QoJy51c2EtZm9vdGVyLWJpZyBuYXYgLnVzYS1mb290ZXItcHJpbWFyeS1saW5rJyk7XG5cbiAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgZS5vZmYoKTtcbiAgICB9KTtcbiAgICBldmVudHMgPSBbXTtcbiAgfVxuXG4gIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDYwMCkge1xuXG4gICAgbmF2TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfSk7XG5cbiAgICBwcmltYXJ5TGluay5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIGRpc3BhdGNoKGVsLCAnY2xpY2snLCBzaG93UGFuZWxMaXN0ZW5lcilcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICBuYXZMaXN0LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsInZhciBzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9zZWxlY3QnKTtcbnZhciBkaXNwYXRjaCA9IHJlcXVpcmUoJy4uL3V0aWxzL2Rpc3BhdGNoJyk7XG5cbnZhciBjbGlja0V2ZW50ID0gKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0b3VjaHN0YXJ0JyA6ICdjbGljaycpO1xudmFyIGRpc3BhdGNoZXJzID0gW107XG5cbmZ1bmN0aW9uIGhhbmRsZU5hdkVsZW1lbnRzIChlKSB7XG5cbiAgdmFyIHRvZ2dsZUVsZW1lbnRzID0gc2VsZWN0KCcudXNhLW92ZXJsYXksIC51c2EtbmF2Jyk7XG4gIHZhciBuYXZDbG9zZUVsZW1lbnQgPSBzZWxlY3QoJy51c2EtbmF2LWNsb3NlJylbIDAgXTtcblxuICB0b2dnbGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdpcy12aXNpYmxlJyk7XG4gIH0pO1xuXG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgndXNhLW1vYmlsZV9uYXYtYWN0aXZlJyk7XG4gIG5hdkNsb3NlRWxlbWVudC5mb2N1cygpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbmF2SW5pdCAoKSB7XG4gIHZhciBuYXZFbGVtZW50cyA9IHNlbGVjdCgnLnVzYS1tZW51LWJ0biwgLnVzYS1vdmVybGF5LCAudXNhLW5hdi1jbG9zZScpO1xuXG4gIGRpc3BhdGNoZXJzID0gbmF2RWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGhhbmRsZU5hdkVsZW1lbnRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5hdk9mZiAoKSB7XG4gIHdoaWxlIChkaXNwYXRjaGVycy5sZW5ndGgpIHtcbiAgICBkaXNwYXRjaGVycy5wb3AoKS5vZmYoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdkluaXQ7XG5tb2R1bGUuZXhwb3J0cy5vZmYgPSBuYXZPZmY7XG4iLCJ2YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvc2VsZWN0Jyk7XG52YXIgZGlzcGF0Y2ggPSByZXF1aXJlKCcuLi91dGlscy9kaXNwYXRjaCcpO1xuXG52YXIgVklTVUFMTFlfSElEREVOID0gJ3VzYS1zci1vbmx5JztcblxudmFyIGNsaWNrRXZlbnQgPSAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuICA/ICd0b3VjaHN0YXJ0J1xuICA6ICdjbGljayc7XG5cbnZhciBzZWFyY2hGb3JtO1xudmFyIHNlYXJjaEJ1dHRvbjtcbnZhciBzZWFyY2hCdXR0b25Db250YWluZXI7XG5cbnZhciBhY3RpdmF0ZURpc3BhdGNoZXI7XG52YXIgZGVhY3RpdmF0ZURpc3BhdGNoZXI7XG5cbmZ1bmN0aW9uIHNlYXJjaEJ1dHRvbkNsaWNrSGFuZGxlciAoZXZlbnQpIHtcbiAgaWYgKHNlYXJjaEZvcm0uaGlkZGVuKSB7XG4gICAgY2xvc2VTZWFyY2goKTtcbiAgfSBlbHNlIHtcbiAgICBvcGVuU2VhcmNoKCk7XG4gICAgZGVhY3RpdmF0ZURpc3BhdGNoZXIgPSBkaXNwYXRjaChkb2N1bWVudC5ib2R5LCBjbGlja0V2ZW50LCBzZWFyY2hPcGVuQ2xpY2tIYW5kbGVyKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoT3BlbkNsaWNrSGFuZGxlciAoZXZlbnQpIHtcbiAgaWYgKCEgc2VhcmNoRm9ybUNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICBjbG9zZVNlYXJjaCgpO1xuICAgIGRlYWN0aXZhdGVEaXNwYXRjaGVyLm9mZigpO1xuICAgIGRlYWN0aXZhdGVEaXNwYXRjaGVyID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9wZW5TZWFyY2ggKCkge1xuICBzZWFyY2hGb3JtLmNsYXNzTGlzdC5yZW1vdmUoVklTVUFMTFlfSElEREVOKTtcbiAgdmFyIGlucHV0ID0gc2VhcmNoRm9ybS5xdWVyeVNlbGVjdG9yKCdbdHlwZT1zZWFyY2hdJyk7XG4gIGlmIChpbnB1dCkge1xuICAgIGlucHV0LmZvY3VzKCk7XG4gIH1cbiAgc2VhcmNoQnV0dG9uLmhpZGRlbiA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlU2VhcmNoICgpIHtcbiAgc2VhcmNoRm9ybS5jbGFzc0xpc3QuYWRkKFZJU1VBTExZX0hJRERFTik7XG4gIHNlYXJjaEJ1dHRvbi5oaWRkZW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoRm9ybUNvbnRhaW5zIChlbGVtZW50KSB7XG4gIHJldHVybiAoc2VhcmNoRm9ybSAmJiBzZWFyY2hGb3JtLmNvbnRhaW5zKGVsZW1lbnQpKSB8fFxuICAgICAgICAgKHNlYXJjaEJ1dHRvbkNvbnRhaW5lciAmJiBzZWFyY2hCdXR0b25Db250YWluZXIuY29udGFpbnMoZWxlbWVudCkpO1xufVxuXG5mdW5jdGlvbiBzZWFyY2hJbml0ICgpIHtcbiAgc2VhcmNoRm9ybSA9IHNlbGVjdCgnLmpzLXNlYXJjaC1mb3JtJylbIDAgXTtcbiAgc2VhcmNoQnV0dG9uID0gc2VsZWN0KCcuanMtc2VhcmNoLWJ1dHRvbicpWyAwIF07XG4gIHNlYXJjaEJ1dHRvbkNvbnRhaW5lciA9IHNlbGVjdCgnLmpzLXNlYXJjaC1idXR0b24tY29udGFpbmVyJylbIDAgXTtcblxuICBpZiAoc2VhcmNoQnV0dG9uICYmIHNlYXJjaEZvcm0pIHtcbiAgICBjbG9zZVNlYXJjaCgpO1xuICAgIGFjdGl2YXRlRGlzcGF0Y2hlciA9IGRpc3BhdGNoKHNlYXJjaEJ1dHRvbiwgY2xpY2tFdmVudCwgc2VhcmNoQnV0dG9uQ2xpY2tIYW5kbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWFyY2hPZmYgKCkge1xuICBpZiAoYWN0aXZhdGVEaXNwYXRjaGVyKSB7XG4gICAgYWN0aXZhdGVEaXNwYXRjaGVyLm9mZigpO1xuICB9XG4gIGlmIChkZWFjdGl2YXRlRGlzcGF0Y2hlcikge1xuICAgIGRlYWN0aXZhdGVEaXNwYXRjaGVyLm9mZigpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VhcmNoSW5pdDtcbm1vZHVsZS5leHBvcnRzLm9mZiA9IHNlYXJjaE9mZjtcbiIsIi8qKlxuICogRmxpcHMgZ2l2ZW4gSU5QVVQgZWxlbWVudHMgYmV0d2VlbiBtYXNrZWQgKGhpZGluZyB0aGUgZmllbGQgdmFsdWUpIGFuZCB1bm1hc2tlZFxuICogQHBhcmFtIHtBcnJheS5IVE1MRWxlbWVudH0gZmllbGRzIC0gQW4gYXJyYXkgb2YgSU5QVVQgZWxlbWVudHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayAtIFdoZXRoZXIgdGhlIG1hc2sgc2hvdWxkIGJlIGFwcGxpZWQsIGhpZGluZyB0aGUgZmllbGQgdmFsdWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmllbGRzLCBtYXNrKSB7XG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgZmllbGQuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCBtYXNrID8gJ3Bhc3N3b3JkJyA6ICd0ZXh0Jyk7XG4gIH0pO1xufTtcbiIsInZhciB0b2dnbGVGaWVsZE1hc2sgPSByZXF1aXJlKCcuL3RvZ2dsZS1maWVsZC1tYXNrJyk7XG52YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvc2VsZWN0Jyk7XG5cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgZGVjb3JhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhYmlsaXR5IHRvIHRvZ2dsZSB0aGVcbiAqIG1hc2tlZCBzdGF0ZSBvZiBhbiBpbnB1dCBmaWVsZCAobGlrZSBhIHBhc3N3b3JkKSB3aGVuIGNsaWNrZWQuXG4gKiBUaGUgaWRzIG9mIHRoZSBmaWVsZHMgdG8gYmUgbWFza2VkIHdpbGwgYmUgcHVsbGVkIGRpcmVjdGx5IGZyb20gdGhlIGJ1dHRvbidzXG4gKiBgYXJpYS1jb250cm9sc2AgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBQYXJlbnQgZWxlbWVudCBjb250YWluaW5nIHRoZSBmaWVsZHMgdG8gYmUgbWFza2VkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNob3dUZXh0ICAgQnV0dG9uIHRleHQgc2hvd24gd2hlbiBmaWVsZCBpcyBtYXNrZWRcbiAqIEBwYXJhbSAge1N0cmluZ30gaGlkZVRleHQgICBCdXR0b24gdGV4dCBzaG93IHdoZW4gZmllbGQgaXMgdW5tYXNrZWRcbiAqIEByZXR1cm4ge31cbiAqL1xudmFyIHRvZ2dsZUZvcm1JbnB1dCA9IGZ1bmN0aW9uIChlbCwgc2hvd1RleHQsIGhpZGVUZXh0KSB7XG4gIHZhciBkZWZhdWx0U2VsZWN0b3JzID0gZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyk7XG5cbiAgaWYgKCFkZWZhdWx0U2VsZWN0b3JzIHx8IGRlZmF1bHRTZWxlY3RvcnMudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlkIHlvdSBmb3JnZXQgdG8gZGVmaW5lIHNlbGVjdG9ycyBpbiB0aGUgYXJpYS1jb250cm9scyBhdHRyaWJ1dGU/IENoZWNrIGVsZW1lbnQgJyArIGVsLm91dGVySFRNTCk7XG4gIH1cblxuICB2YXIgZmllbGRTZWxlY3RvciA9IGdldFNlbGVjdG9ycyhkZWZhdWx0U2VsZWN0b3JzKTtcbiAgdmFyIGZvcm1FbGVtZW50ID0gZ2V0Rm9ybVBhcmVudChlbCk7XG4gIGlmICghZm9ybUVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvZ2dsZUZvcm1JbnB1dCgpIG5lZWRzIHRoZSBzdXBwbGllZCBlbGVtZW50IHRvIGJlIGluc2lkZSBhIDxmb3JtPi4gQ2hlY2sgZWxlbWVudCAnICsgZWwub3V0ZXJIVE1MKTtcbiAgfVxuICB2YXIgZmllbGRzID0gc2VsZWN0KGZpZWxkU2VsZWN0b3IsIGZvcm1FbGVtZW50KTtcbiAgdmFyIG1hc2tlZCA9IGZhbHNlO1xuXG4gIHZhciB0b2dnbGVDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB0b2dnbGVGaWVsZE1hc2soZmllbGRzLCBtYXNrZWQpO1xuICAgIGVsLnRleHRDb250ZW50ID0gbWFza2VkID8gc2hvd1RleHQgOiBoaWRlVGV4dDtcbiAgICBtYXNrZWQgPSAhbWFza2VkO1xuICB9O1xuXG4gIGlmIChlbC5hdHRhY2hFdmVudCkge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbmNsaWNrJywgdG9nZ2xlQ2xpY2tMaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0b2dnbGVDbGlja0xpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHVybiBhIHN0cmluZyBvZiBpZHMgaW50byB2YWxpZCBzZWxlY3RvcnNcbiAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3JzIFNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGlkcyBvZiBmaWVsZHMgdG8gYmUgbWFza2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBzZWxlY3RvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0b3JzIChzZWxlY3RvcnMpIHtcbiAgdmFyIHNlbGVjdG9yc0xpc3QgPSBzZWxlY3RvcnMuc3BsaXQoJyAnKTtcblxuICByZXR1cm4gc2VsZWN0b3JzTGlzdC5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICcjJyArIHNlbGVjdG9yO1xuICB9KS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIHVwIHRoZSB0cmVlIGZyb20gdGhlIGVsZW1lbnQgdG8gZmluZCBhIEZvcm0gZWxlbWVudCwgYW5kIHJldHVybnMgaXQsXG4gKiBvciBudWxsIGlmIG5vIEZvcm0gaXMgZm91bmRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gQ2hpbGQgZWxlbWVudCB0byBzdGFydCBzZWFyY2hcbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybVBhcmVudCAoZWwpIHtcbiAgd2hpbGUgKGVsICYmIGVsLnRhZ05hbWUgIT09ICdGT1JNJykge1xuICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9nZ2xlRm9ybUlucHV0O1xuIiwidmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NlbGVjdCcpO1xudmFyIGRpc3BhdGNoID0gcmVxdWlyZSgnLi4vdXRpbHMvZGlzcGF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0b3IgKGVsKSB7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbCk7XG4gIHZhciBrZXk7XG4gIHZhciB2YWxpZGF0b3JOYW1lO1xuICB2YXIgdmFsaWRhdG9yUGF0dGVybjtcbiAgdmFyIHZhbGlkYXRvckNoZWNrYm94O1xuICB2YXIgY2hlY2tMaXN0ID0gc2VsZWN0KGRhdGEudmFsaWRhdGlvbmVsZW1lbnQpWyAwIF07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUgKCkge1xuICAgIGZvciAoa2V5IGluIGRhdGEpIHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgndmFsaWRhdGUnKSkge1xuICAgICAgICB2YWxpZGF0b3JOYW1lID0ga2V5LnNwbGl0KCd2YWxpZGF0ZScpWyAxIF07XG4gICAgICAgIHZhbGlkYXRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKGRhdGFbIGtleSBdKTtcbiAgICAgICAgdmFsaWRhdG9yU2VsZWN0b3IgPSAnW2RhdGEtdmFsaWRhdG9yPScgKyB2YWxpZGF0b3JOYW1lICsgJ10nO1xuICAgICAgICB2YWxpZGF0b3JDaGVja2JveCA9IHNlbGVjdCh2YWxpZGF0b3JTZWxlY3RvciwgY2hlY2tMaXN0KVsgMCBdO1xuXG4gICAgICAgIHZhciBjaGVja2VkID0gdmFsaWRhdG9yUGF0dGVybi50ZXN0KGVsLnZhbHVlKTtcbiAgICAgICAgdmFsaWRhdG9yQ2hlY2tib3guY2xhc3NMaXN0LnRvZ2dsZSgndXNhLWNoZWNrbGlzdC1jaGVja2VkJywgY2hlY2tlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2goZWwsICdrZXl1cCcsIHZhbGlkYXRlKTtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgYXR0cmlidXRlcyBuYW1lZCB3aXRoIHRoZSBwYXR0ZXJuIFwiZGF0YS1bTkFNRV1cIiBmcm9tIGEgZ2l2ZW5cbiAqIEhUTUxFbGVtZW50LCB0aGVuIHJldHVybnMgYW4gb2JqZWN0IHBvcHVsYXRlZCB3aXRoIHRoZSBOQU1FL3ZhbHVlIHBhaXJzLlxuICogQW55IGh5cGhlbnMgaW4gTkFNRSBhcmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZWwpIHtcbiAgaWYgKCFlbC5oYXNBdHRyaWJ1dGVzKCkpIHJldHVybjtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcztcbiAgZm9yICh2YXIgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBhdHRyc1sgaSBdLm5hbWUubWF0Y2goL2RhdGEtKC4qKS9pKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzWyAxIF0pIHtcbiAgICAgIHZhciBuYW1lID0gbWF0Y2hlc1sgMSBdLnJlcGxhY2UoLy0vLCAnJyk7XG4gICAgICBkYXRhWyBuYW1lIF0gPSBhdHRyc1sgaSBdLnZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbiIsInZhciBzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlscy9zZWxlY3QnKTtcbnZhciB3aGVuRE9NUmVhZHkgPSByZXF1aXJlKCcuLi91dGlscy93aGVuLWRvbS1yZWFkeScpO1xudmFyIEFjY29yZGlvbiA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvYWNjb3JkaW9uJyk7XG5cbndoZW5ET01SZWFkeShmdW5jdGlvbiBpbml0QWNjb3JkaW9ucyAoKSB7XG5cbiAgdmFyIGFjY29yZGlvbnMgPSBzZWxlY3QoJy51c2EtYWNjb3JkaW9uLCAudXNhLWFjY29yZGlvbi1ib3JkZXJlZCcpO1xuICBhY2NvcmRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgbmV3IEFjY29yZGlvbihlbCk7XG4gIH0pO1xufSk7XG4iLCJ2YXIgd2hlbkRPTVJlYWR5ID0gcmVxdWlyZSgnLi4vdXRpbHMvd2hlbi1kb20tcmVhZHknKTtcbnZhciBiYW5uZXJJbml0ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9iYW5uZXInKTtcblxud2hlbkRPTVJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICBiYW5uZXJJbml0KCk7XG5cbn0pO1xuXG4iLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKTtcbnZhciB3aGVuRE9NUmVhZHkgPSByZXF1aXJlKCcuLi91dGlscy93aGVuLWRvbS1yZWFkeScpO1xudmFyIGRpc3BhdGNoID0gcmVxdWlyZSgnLi4vdXRpbHMvZGlzcGF0Y2gnKTtcbnZhciBmb290ZXJBY2NvcmRpb24gPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL2Zvb3RlcicpO1xuXG53aGVuRE9NUmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gIGZvb3RlckFjY29yZGlvbigpO1xuXG4gIGRpc3BhdGNoKHdpbmRvdywgJ3Jlc2l6ZScsIGRlYm91bmNlKGZvb3RlckFjY29yZGlvbiwgMTgwKSk7XG5cbn0pO1xuIiwidmFyIHdoZW5ET01SZWFkeSA9IHJlcXVpcmUoJy4uL3V0aWxzL3doZW4tZG9tLXJlYWR5Jyk7XG52YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvc2VsZWN0Jyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy92YWxpZGF0b3InKTtcbnZhciB0b2dnbGVGb3JtSW5wdXQgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL3RvZ2dsZS1mb3JtLWlucHV0Jyk7XG5cbndoZW5ET01SZWFkeShmdW5jdGlvbiAoKSB7XG4gIHZhciBlbFNob3dQYXNzd29yZCA9IHNlbGVjdCgnLnVzYS1zaG93X3Bhc3N3b3JkJylbIDAgXTtcbiAgdmFyIGVsRm9ybUlucHV0ID0gc2VsZWN0KCcudXNhLXNob3dfbXVsdGlwYXNzd29yZCcpWyAwIF07XG4gIHZhciBlbFZhbGlkYXRvciA9IHNlbGVjdCgnLmpzLXZhbGlkYXRlX3Bhc3N3b3JkJylbIDAgXTtcblxuICBlbFNob3dQYXNzd29yZCAmJiB0b2dnbGVGb3JtSW5wdXQoZWxTaG93UGFzc3dvcmQsICdTaG93IFBhc3N3b3JkJywgJ0hpZGUgUGFzc3dvcmQnKTtcbiAgZWxGb3JtSW5wdXQgJiYgdG9nZ2xlRm9ybUlucHV0KGVsRm9ybUlucHV0LCAnU2hvdyBteSB0eXBpbmcnLCAnSGlkZSBteSB0eXBpbmcnKTtcbiAgZWxWYWxpZGF0b3IgJiYgdmFsaWRhdG9yKGVsVmFsaWRhdG9yKTtcbn0pO1xuXG4iLCJ2YXIgd2hlbkRPTVJlYWR5ID0gcmVxdWlyZSgnLi4vdXRpbHMvd2hlbi1kb20tcmVhZHknKTtcbnZhciBuYXZJbml0ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9uYXZpZ2F0aW9uJyk7XG5cbndoZW5ET01SZWFkeShuYXZJbml0KTtcbiIsIi8vIHN1cHBvcnQgZm9yIEhUTUxFbGVtZW50I2hpZGRlblxucmVxdWlyZSgnLi4vcG9seWZpbGxzL2VsZW1lbnQtaGlkZGVuJyk7XG4vLyBzdXBwb3J0IGZvciBFbGVtZW50I2NsYXNzTGlzdFxucmVxdWlyZSgnY2xhc3NsaXN0LXBvbHlmaWxsJyk7XG5cbi8qKlxuICogVGhpcyBmaWxlIGRlZmluZXMga2V5IEVDTUFTY3JpcHQgNSBtZXRob2RzIHRoYXQgYXJlIHVzZWQgYnkgdGhlIFN0YW5kYXJkc1xuICogYnV0IG1heSBiZSBtaXNzaW5nIGluIG9sZGVyIGJyb3dzZXJzLlxuICovXG5cbi8qKlxuICogQXJyYXkucHJvdG90eXBlLmZvckVhY2goKVxuICogVGFrZW4gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4gKi9cblxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMThcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuXG4gICAgdmFyIFQsIGs7XG5cbiAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignIHRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0b09iamVjdCgpIHBhc3NpbmcgdGhlXG4gICAgLy8gfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cbiAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcblxuICAgIC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCgpIGludGVybmFsXG4gICAgLy8gbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAvLyAzLiBMZXQgbGVuIGJlIHRvVWludDMyKGxlblZhbHVlKS5cbiAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7XG5cbiAgICAvLyA0LiBJZiBpc0NhbGxhYmxlKGNhbGxiYWNrKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLiBcbiAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldFxuICAgIC8vIFQgYmUgdW5kZWZpbmVkLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgVCA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgIGsgPSAwO1xuXG4gICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgd2hpbGUgKGsgPCBsZW4pIHtcblxuICAgICAgdmFyIGtWYWx1ZTtcblxuICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuICAgICAgLy8gICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxuICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHlcbiAgICAgIC8vICAgIGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAvLyAgICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuICAgICAgaWYgKGsgaW4gTykge1xuXG4gICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWxcbiAgICAgICAgLy8gbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAga1ZhbHVlID0gT1sgayBdO1xuXG4gICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXNcbiAgICAgICAgLy8gdGhlIHRoaXMgdmFsdWUgYW5kIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyBrVmFsdWUsIGssIGFuZCBPLlxuICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XG4gICAgICB9XG4gICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICBrKys7XG4gICAgfVxuICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcbiAgfTtcbn1cblxuXG4vKipcbiAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKClcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxuICovXG5cbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNVxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuXG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcbiAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgfVxuXG4gICAgdmFyIGFBcmdzICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICBmTk9QICAgID0gZnVuY3Rpb24gKCkge30sXG4gICAgICBmQm91bmQgID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCA/IHRoaXMgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgfTtcblxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlIGRvZXNuJ3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eVxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTsgXG4gICAgfVxuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcblxufVxuIiwidmFyIHdoZW5ET01SZWFkeSA9IHJlcXVpcmUoJy4uL3V0aWxzL3doZW4tZG9tLXJlYWR5Jyk7XG52YXIgc2VhcmNoSW5pdCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvc2VhcmNoJyk7XG5cbndoZW5ET01SZWFkeShzZWFyY2hJbml0KTtcbiIsInZhciBkaXNwYXRjaCA9IHJlcXVpcmUoJy4uL3V0aWxzL2Rpc3BhdGNoJyk7XG52YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbHMvc2VsZWN0Jyk7XG52YXIgd2hlbkRPTVJlYWR5ID0gcmVxdWlyZSgnLi4vdXRpbHMvd2hlbi1kb20tcmVhZHknKTtcblxud2hlbkRPTVJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAvLyBGaXhpbmcgc2tpcCBuYXYgZm9jdXMgYmVoYXZpb3IgaW4gY2hyb21lXG4gIHZhciBlbFNraXBuYXYgPSBzZWxlY3QoJy5za2lwbmF2JylbIDAgXTtcbiAgdmFyIGVsTWFpbkNvbnRlbnQgPSBzZWxlY3QoJyNtYWluLWNvbnRlbnQnKVsgMCBdO1xuXG4gIGlmIChlbFNraXBuYXYpIHtcbiAgICBkaXNwYXRjaChlbFNraXBuYXYsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsTWFpbkNvbnRlbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZWxNYWluQ29udGVudCkge1xuICAgIGRpc3BhdGNoKGVsTWFpbkNvbnRlbnQsICdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWxNYWluQ29udGVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwidmFyIGVscHJvdG8gPSB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlO1xudmFyIEhJRERFTiA9ICdoaWRkZW4nO1xuXG5pZiAoIShISURERU4gaW4gZWxwcm90bykpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxwcm90bywgSElEREVOLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoSElEREVOKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoSElEREVOLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShISURERU4pO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSAncG9seWZpbGxzJyBmaWxlIGRlZmluZXMga2V5IEVDTUFTY3JpcHQgNSBtZXRob2RzIHRoYXQgbWF5IGJlXG4gKiBtaXNzaW5nIGZyb20gb2xkZXIgYnJvd3NlcnMsIHNvIG11c3QgYmUgbG9hZGVkIGZpcnN0LlxuICovXG5yZXF1aXJlKCcuL2luaXRpYWxpemVycy9wb2x5ZmlsbHMnKTtcblxucmVxdWlyZSgnLi9pbml0aWFsaXplcnMvYWNjb3JkaW9ucycpO1xucmVxdWlyZSgnLi9pbml0aWFsaXplcnMvYmFubmVyJyk7XG5yZXF1aXJlKCcuL2luaXRpYWxpemVycy9mb290ZXInKTtcbnJlcXVpcmUoJy4vaW5pdGlhbGl6ZXJzL2Zvcm1zJyk7XG5yZXF1aXJlKCcuL2luaXRpYWxpemVycy9uYXZpZ2F0aW9uJyk7XG5yZXF1aXJlKCcuL2luaXRpYWxpemVycy9zZWFyY2gnKTtcbnJlcXVpcmUoJy4vaW5pdGlhbGl6ZXJzL3NraXAtbmF2Jyk7XG4iLCIvKipcbiAqIEF0dGFjaGVzIGEgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24gdG8gYSBnaXZlbiBlbGVtZW50IHdoaWNoIGlzXG4gKiB0cmlnZ2VyZWQgYnkgYSBzcGVjaWZpZWQgbGlzdCBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhdHRhY2hlZFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZXMgLSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBldmVudCB0eXBlcyB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICogQHJldHVybnMge09iamVjdH0gLSBjb250YWluaW5nIGEgPHR0PnRyaWdnZXIoKTwvdHQ+IG1ldGhvZCBmb3IgZXhlY3V0aW5nIHRoZSBsaXN0ZW5lciwgYW5kIGFuIDx0dD5vZmYoKTwvdHQ+IG1ldGhvZCBmb3IgZGV0YWNoaW5nIGl0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2ggKGVsZW1lbnQsIGV2ZW50VHlwZXMsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gIHZhciBldmVudFR5cGVBcnJheSA9IGV2ZW50VHlwZXMuc3BsaXQoL1xccysvKTtcblxuICB2YXIgYXR0YWNoID0gZnVuY3Rpb24gKGUsIHQsIGQpIHtcbiAgICBpZiAoZS5hdHRhY2hFdmVudCkge1xuICAgICAgZS5hdHRhY2hFdmVudCgnb24nICsgdCwgZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcih0LCBkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRyaWdnZXIgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIHZhciBmYWtlRXZlbnQ7XG4gICAgaWYgKCdjcmVhdGVFdmVudCcgaW4gZG9jdW1lbnQpIHtcbiAgICAgIC8vIG1vZGVybiBicm93c2VycywgSUU5K1xuICAgICAgZmFrZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICAgIGZha2VFdmVudC5pbml0RXZlbnQodCwgZmFsc2UsIHRydWUpO1xuICAgICAgZS5kaXNwYXRjaEV2ZW50KGZha2VFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIDhcbiAgICAgIGZha2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgICBmYWtlRXZlbnQuZXZlbnRUeXBlID0gdDtcbiAgICAgIGUuZmlyZUV2ZW50KCdvbicrZS5ldmVudFR5cGUsIGZha2VFdmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZXRhY2ggPSBmdW5jdGlvbiAoZSwgdCwgZCkge1xuICAgIGlmIChlLmRldGFjaEV2ZW50KSB7XG4gICAgICBlLmRldGFjaEV2ZW50KCdvbicgKyB0LCBkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICBldmVudFR5cGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICBhdHRhY2guY2FsbChudWxsLCBlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmlnZ2VyLmNhbGwobnVsbCwgZWxlbWVudCwgZXZlbnRUeXBlQXJyYXlbIDAgXSk7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGV2ZW50VHlwZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICBkZXRhY2guY2FsbChudWxsLCBlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59O1xuIiwiLyoqXG4gKiBAbmFtZSBzZWxlY3RcbiAqIEBkZXNjIHNlbGVjdHMgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGJ5IGNsYXNzIHNlbGVjdG9yIG9yIElEIHNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gVGhlIHNlbGVjdG9yIHRvIHRyYXZlcnNlIHRoZSBET00gd2l0aC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB0cmF2ZXJzZSB0aGUgRE9NIGluLlxuICogQHJldHVybiB7QXJyYXkuSFRNTEVsZW1lbnR9IC0gQW4gYXJyYXkgb2YgRE9NIG5vZGVzIG9yIGFuIGVtcHR5IGFycmF5LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlbGVjdCAoc2VsZWN0b3IsIGNvbnRleHQpIHtcblxuICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICgoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB8fCAhaXNFbGVtZW50KGNvbnRleHQpKSB7XG4gICAgY29udGV4dCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzZWxlY3Rpb24pO1xuXG59O1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQgKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59IiwiLypcbiAqIEBuYW1lIERPTUxvYWRlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIERPTSBoYXMgbG9hZGVkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIERPTUxvYWRlZCAoY2IpIHtcbiAgLy8gaW4gY2FzZSB0aGUgZG9jdW1lbnQgaXMgYWxyZWFkeSByZW5kZXJlZFxuICBpZiAoJ2xvYWRpbmcnICE9PSBkb2N1bWVudC5yZWFkeVN0YXRlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY2IpKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gIH0gZWxzZSB7IC8vIElFIDw9IDhcbiAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCl7XG4gICAgICBpZiAoJ2NvbXBsZXRlJyA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYikpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpO1xufSJdfQ==\n"

/***/ })

},[1099]);
//# sourceMappingURL=scripts.bundle.js.map